use (
  {RunCommand as RunCommandBase} = alias://cli
  {ConstStage} = alias://stages
  {ConstStarter, SleepStarter, BlankSheetStream} = alias://generator
  {RandomAssigner, Ring, RunReqStream} = alias://generator
  {ConsoleDistributor, RedisDistributor} = alias://generator

  _StageCommand
)

/**
 * Options defined in the super types.
 */
const {baseOptions} = RunCommandBase

/**
 * The run command.
 */
export struct RunCommand: RunCommandBase:: _StageCommand
  @override
  pub const name := ["run [stageName]", "r"]

  @override
  pub const desc := "Run a stage from a catalog."

  @override
  pub const positionals := {
    stageName =
      type = "string"
      desc = "Stage name to run. If unset, defaultStageName used."
  }

  @override
  pub const options := {
    {registries} = baseOptions
    {catalogName} = baseOptions
    {registryAndCatalogName} = baseOptions
    {arg} = baseOptions
  }

  @override @hidden
  pub async proc handle(argv=> {catalogName, registryAndCatalogName, stageName, args})
    # (1) create the registry instances to use
    const registries = await(self.createRegistries(argv).connect())

    var code  # ps exit code

    do
      # (2) determine the catalogName
      if registryAndCatalogName then
        catalogName = registryAndCatalogName.split("://")[1]

      # (3) get the catalog decl
      const decl = await(self.readCatalogDecl(
        (catalogName = self.buildCatalogPath(catalogName))
        registries
      ))

      if not decl then
        print($"Stage catalog '${catalogName}' not found in '${registries.registryNames}'.")
        ps.exit(1)
      
      # (4) create global dataset
      const dataset = await(self.createGlobalDataset(decl, args))

      # (5) create catalog instance
      const catalog = await(self.createCatalog(decl, dataset))

      # (6) run stage
      if not (stageName ?= catalog.defaultStageName) then
        console.error("Catalog doesn't contain default stage name.")
        code = 2
      else
        if stage ::= catalog.stages[stageName]; not stage then
          console.error($"Stage not found: ${stageName}.")
          code = 2
        else
          const args = dataset.getDatumValue("args")

          if [ok, value] ::= pawait(self.runStage(stage, args.botnet)); ok then
            code = 0
          else
            code = 1
            if value then printf(value)
    finally
      pawait(registries.disconnect())
    
    ps.exit(code)

  /**
   * Creates a stage catalog instance.
   */
  @hidden
  pub async fn createCatalog(decl: map, globalDataset) -> catalog
    const catalogParser = self.createCatalogParser()

    catalog = await(catalogParser.parse(
      decl
      parentDataset = globalDataset
    ))

  /**
   * Run stage.
   */
  @hidden @async
  pub fn runStage(stage, botnet: {impl: text, bots: map[]})
    # (1) create starter
    var (
      starter: Starter
      starterOutput ::= BlankSheetStream()
      times ::= stage.duration / stage.interval
      blankSheets ::= stage.requests
      starterProps ::= stage{*, output = starterOutput, times, blankSheets}
    )
      
    with type(stage) do
      if ConstStage then starter = ConstStarter(starterProps)
      if SleepStage then starter = SleepStarter(starterProps)
      else throw(Error($"Unknown stage: ${fmt(stage)}."))
    
    # (2) create assigner
    const (
      assignerOutput = RunReqStream()
      assignations = stage.jobs
      ring = Ring(points = botnet.bots.map(fn(bot) = bot.bot end))
      assignerProps = {input = starterOutput, output = assignerOutput, ring, assignations}
      assigner = RandomAssigner(assignerProps)
    )

    # (3) create distributor
    var (
      distributor: Distributor
      distributorInput ::= assignerOutput
      distributorProps ::= botnet{*, input = distributorInput}
    )

    with i ::= botnet.impl do
      if "console" then distributor = ConsoleDistributor(distributorProps)
      if "redis" then distributor = RedisDistributor(distributorProps)
      else throw(TypeError($"Unknown botnet impl: ${i}."))

    # (4) starts
    return Promise.all([
      starter.start()
      assigner.start()
      distributor.start()
    ])
