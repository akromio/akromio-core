use (
  alias://expected
  {simulator} = alias://doubles
  {GlobalDataset} = alias://dataset
  {Ops, StaticAction as Action, ActionOperator, LoopOperator, Call, Context} = alias://core
  {CatalogLoop} = ~
)

suite(__filename, proc()
  const (
    dataset = GlobalDataset(name = "global")
    log = simulator.stream.duplex()
    ctx = Context(log = nop)
    onError = "carryOn"
    title = "testing"
    operator = LoopOperator()
  )

  suite("buildSteps()", proc()
    test("when decls are alright, a list with the steps must be returned", proc()
      # (1) act
      const (
        op1 = Action(name = "list", fun = nop, operator = ActionOperator())
        ops = Ops().appendOp(op1)
        forEach = ["list", "file1", "file2"]
        steps = []
        loop = CatalogLoop(name = "test", forEach, steps, ops, operator)
        call = Call(op = loop, dataset, onError, title, log, ctx)
        out = loop.getCollection(call)
      )

      # (2) assessment
      expected(out).toBeMap().toHave(
        args = ["file1", "file2"]
        onError = "carryOn"
        resultVarName = "i"
      ).member("op").toBe(Action)
    end)

    test("when decls are alright, a list with the steps must be returned", proc()
      # (1) act
      const (
        op1 = Action(name = "cp", fun = nop, operator = ActionOperator())
        ops = Ops().appendOp(op1)
        forEach = ["list", "file1", "file2"]
        steps = [
          ["<cp", "$(dst)", "$(dst).old"]
          ["cp", "$(src)", "$(dst)"]
        ]
        loop = CatalogLoop(name = "test", forEach, steps, ops, operator)
        call = Call(op = loop, dataset, onError, title, log, ctx)
        out = loop.getSteps(call)
      )

      # (2) assessment
      expected(out).toBeList().toHaveLen(2)

      expected(out[0]).toBeMap().toHave(
        args = ["$(dst)", "$(dst).old"]
        onError = "finish"
        resultVarName = "last"
       ).member("op").toBe(Action)

      expected(out[1]).toBeMap().toHave(
        args = ["$(src)", "$(dst)"]
        onError = "carryOn"
        resultVarName = "last"
      ).member("op").toBe(Action)
    end)
  end)

  suite("getInitializerSteps()", proc()
    test("when called, the steps must be built and returned", proc()
      # (1) act
      const (
        cpOp = Action(name = "cp", fun = nop, operator = ActionOperator())
        ops = Ops().appendOp(cpOp)
        forEach = []
        initializers = ["cp"]
        steps = []
        loop = CatalogLoop(name = "test", forEach, initializers, steps, ops, operator)
        call = Call(op = loop, dataset, onError, title, log, ctx)
        out = loop.getInitializerSteps(call)
      )

      # (2) assessment
      expected(out).toHaveLen(1)
      expected(out[0].op).toBe(Action)
    end)
  end)

  suite("getFinalizerSteps()", proc()
    test("when called, the steps must be built and returned", proc()
      # (1) act
      const (
        cpOp = Action(name = "cp", fun = nop, operator = ActionOperator())
        ops = Ops().appendOp(cpOp)
        forEach = []
        finalizers = ["cp"]
        steps = []
        loop = CatalogLoop(name = "test", forEach, finalizers, steps, ops, operator)
        call = Call(op = loop, dataset, onError, title, log, ctx)
        out = loop.getFinalizerSteps(call)
      )

      # (2) assessment
      expected(out).toHaveLen(1)
      expected(out[0].op).toBe(Action)
    end)
  end)
end)