use (
  alias://expected
  {simulator, method} = alias://doubles
  {Dataset, GlobalDataset, LocalDataset} = alias://dataset
  {Plugin, Plugins, PluginParser, PluginLoader, Ops} = alias://core
  {Catalog as CatalogBase, CatalogParser as CatalogParserBase} = ~
)

# catalog to use with the tests.
struct Catalog: CatalogBase

# parser to use with the tests.
struct CatalogParser: CatalogParserBase
  pub const jobParser = simulator(
    parseJobs = method.invokes(fn(...args) -> parsed: map
      for each decl in args[0] do
        parsed[decl.macro] = decl
    end)
  )
  
  @hidden
  pub fn createCatalog(decl: map) = Catalog(decl)

suite(__filename, proc()
  const (
    globalDataset = GlobalDataset(name = "global")
    parentDataset = globalDataset
    pluginParser = PluginParser()
    pluginLoader = simulator(PluginLoader, {})
    ops = Ops()
    catalogDecl = {
      spec = "v1.0"
      name = "test-catalog"
      loc = "test:///jobs/catalogs/test-catalog"
      cty = "text/yaml"
      desc = "A test catalog."
      jobs = []
    }
  )

  suite("parseDataset()", proc()
    const (
      datasetName = "test"
      parser = CatalogParser(pluginParser=, pluginLoader)
    )

    test("when empty dataset declaration, empty dataset must be returned", async proc()
      # (1) act
      const (
        out = await(parser.parse(
          catalogDecl{*, dataset = []}
          parentDataset=,
          ops
        )).dataset
      )

      # (2) assessment
      expected(out)\
        .toBe(LocalDataset)\
        .member("parent").sameAs(globalDataset)\
        .member("data").toHaveLen(0)
    end)

    test("when dataset with data, a local dataset must be returned", async proc()
      # (1) act
      const (
        out = await(parser.parse(
          catalogDecl{*, dataset = [{var = "mydatum", value = "my value"}]}
          parentDataset=,
          ops
        )).dataset
      )

      # (2) assessment
      expected(out)\
        .toBe(LocalDataset)\
        .member("parent").sameAs(globalDataset)\
        .get("data.mydatum").toBe("VarDatum")
    end)
  end)

  suite("parsePlugins()", proc()
    test("when plugin, a Plugin instance must be returned", async proc()
      # (1) act
      const (
        piWoi = {name = "pi-without-ini", ops = {}}
        piWini = {name = "pi-with-ini", ops = {}, ini = fn() = "value" end}
        plugins = [
          {plugin = "woi", impl = "pi-without-ini"}
          {plugin = "wi", name = "WI", impl = "pi-with-ini"}
        ]

        pluginLoader = simulator(
          PluginLoader
          loadPlugin = method([
            {args = ["pi-without-ini"], returns = piWoi}
            {args = ["pi-with-ini"], returns = piWini}
          ])
        )

        parser = CatalogParser(pluginLoader=, pluginParser)

        out = await(parser.parse(
          catalogDecl{*, plugins}
          parentDataset=,
          ops
        )).plugins
      )

      # (2) assessment
      expected(out).toBe(Plugins).toHaveLen(2)
      expected(out.getPlugin("woi")).toHave(name = "woi", state = nil)
      expected(out.getPlugin("WI")).toHave(name = "WI", state = "value")
    end)

    test("when preset, its plugins must be loaded, parsed and returned", async proc()
      # (1) act
      const (
        pi1 = {
          plugin = "pi1"
          ops =
            op11 = {fun = nop}
            op12 = {fun = nop}
        }

        pi2 = {
          plugin = "pi2"
          ops =
            op21 = {fun = nop}
            op22 = {fun = nop}
        }

        preset = {
          name = "test-preset"
          tags = ["test"]
          plugins = [
            {plugin = pi1.name, impl = pi1}
            {plugin = pi2.name, impl = pi2}
          ]
        }

        plugins = [{preset = "test-preset"}]
        pluginLoader = simulator(
          PluginLoader
          loadPreset = method.returns(preset)
          loadPlugin = method.invokes(fn(...args)
            printf(args)
            return args[0]
          end)
        )
        parser = CatalogParser(pluginLoader=, pluginParser)
        out = await(parser.parse(
          catalogDecl{*, plugins}
          parentDataset=,
          ops
        )).plugins
      )

      # (2) assessment
      expected(out).toHaveLen(2)
      expected(out.getPlugin("pi1")).toHave(name = "pi1")
      expected(out.getPlugin("pi2")).toHave(name = "pi2")
    end)

    test("when unknown plugin item, error must be raised", async proc()
      # (1) act
      const (
        plugins = [{name = "woi", impl = "pi-without-ini"}]
        parser = CatalogParser(pluginLoader=, pluginParser)
        out = pawait(parser.parse(
          catalogDecl{*, plugins}
          parentDataset=,
          ops
        ))
      )

      # (2) assessment
      expected(out)\
        .it(0).equalTo(false)\
        .it(1).equalTo(TypeError("Unknown plugin declaration: { name: 'woi', impl: 'pi-without-ini' }."))
    end)
  end)

  suite("parseTriggers()", proc()
    test("when triggers, triggers must be parsed", async proc()
      # (1) act
      const (
        parser = CatalogParser(pluginLoader=, pluginParser)
        trg1 = {trigger = "trg1"}
        trg2 = {trigger = "trg2"}
        triggers = [trg1, trg2]
        out = await(parser.parse(
          catalogDecl{*, on = triggers}
          parentDataset=,
          ops
        )).triggers
      )

      # (2) assessment
      printf(out)
      expected(out).equalTo(trg1=, trg2)
    end)
  end)

  suite("parseJobs()", proc()
    test("when jobs, jobs must be parsed", async proc()
      # (1) act
      const (
        parser = CatalogParser(pluginLoader=, pluginParser)
        job1 = {macro = "macro1", steps = []}
        job2 = {macro = "macro2", steps = []}
        jobs = [job1, job2]
        out = await(parser.parse(
          catalogDecl{*, jobs}
          parentDataset=,
          ops
        )).jobs
      )

      # (2) assessment
      expected(out).equalTo(
        macro1 = job1
        macro2 = job2
      )
    end)
  end)
end)