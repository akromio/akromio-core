use (
  alias://expected
  {CatalogMerger as CatalogMergerBase} = ~
)

/**
 * The merger to use in the tests.
 */
struct CatalogMerger: CatalogMergerBase

suite(__filename, proc()
  const (
    merger = CatalogMerger()
  )

  suite("merge()", proc()
    test("when other, this is overwritten", proc()
      # (1) act
      const (
        extensor = {
          desc = "extensor"
        }

        extended1 = {
          desc = "extended1"
        }

        extended2 = {
          desc = "extended2"
        }

        out = merger.merge(extensor, extended1, extended2)
      )

      # (2) assessment
      expected(out).toHave(
        desc = "extensor"
      )
    end)
  end)

  suite("mergeDataset()", proc()
    test("when available dataset, this is removed and the replacer is appended in the end", proc()
      # (1) act
      const (
        extensor = {
          dataset = [
            {const = "y", desc = "extensor"}
            {var = "a", desc = "extensor"}
          ]
        }

        extended1 = {
          dataset = [
            {var = "x", desc = "extended1"}
            {var = "y", desc = "extended1"}
          ]
        }

        extended2 = {
          dataset = [
            {var = "y", desc = "extended2"}
            {var = "z", desc = "extended2"}
            {fn = "f", desc = "extended2"}
          ]
        }

        out = merger.merge(extensor, extended1, extended2)
      )

      # (2) assessment
      expected(out.dataset).equalTo([
        {var = "x", desc = "extended1"}
        {var = "z", desc = "extended2"}
        {fn = "f", desc = "extended2"}
        {const = "y", desc = "extensor"}
        {var = "a", desc = "extensor"}
      ])
    end)

    test("when dataset unavailable, empty list must be used", proc()
      # (1) act
      const (
        extended1 = {}

        extended2 = {
          dataset = [
            {var = "y", desc = "extended2"}
            {var = "z", desc = "extended2"}
          ]
        }

        extensor = {}

        out = merger.merge(extensor, extended1, extended2)
      )

      # (2) assessment
      expected(out.dataset).equalTo([
        {var = "y", desc = "extended2"}
        {var = "z", desc = "extended2"}
      ])
    end)
  end)

  suite("mergePlugins()", proc()
    test("when available plugins, extensor plugins are appended at the end of the extended one, removing the extended", proc()
      # (1) act
      const (
        extended = {
          plugins = [
            {plugin = "x", impl = "plugin", desc = "extended"}
            {plugin = "y", impl = "plugin", desc = "extended"}
            {plugin = "z", impl = "plugin", desc = "extended"}
          ]
        }

        extensor = {
          plugins = [
            {plugin = "y", impl = "plugin", desc = "extensor"}
            {plugin = "a", impl = "plugin", desc = "extensor"}
          ]
        }

        out = merger.merge(extensor, extended)
      )

      # (2) assessment
      expected(out.plugins).equalTo([
        {plugin = "x", impl = "plugin", desc = "extended"}
        {plugin = "z", impl = "plugin", desc = "extended"}
        {plugin = "y", impl = "plugin", desc = "extensor"}
        {plugin = "a", impl = "plugin", desc = "extensor"}
      ])
    end)

    test("when plugins are unavailable, empty list must be used", proc()
      # (1) act
      const (
        extended1 = {}

        extended2 = {
          plugins = [
            {plugin = "x", impl = "plugin", desc = "extended2"}
            {plugin = "y", impl = "plugin", desc = "extended2"}
            {plugin = "z", impl = "plugin", desc = "extended2"}
          ]
        }

        extensor = {}
        out = merger.merge(extensor, extended1, extended2)
      )

      # (2) assessment
      expected(out.plugins).equalTo([
        {plugin = "x", impl = "plugin", desc = "extended2"}
        {plugin = "y", impl = "plugin", desc = "extended2"}
        {plugin = "z", impl = "plugin", desc = "extended2"}
      ])
    end)
  end)

  suite("mergeJobs()", proc()
    test("when called, extensor jobs are appended at the end of the extended one, removing the extended", proc()
      # (1) act
      const (
        extended = {
          jobs = [
            {macro = "x", desc = "extended", steps = []}
            {macro = "y", desc = "extended", steps = []}
            {macro = "z", desc = "extended", steps = []}
          ]
        }

        extensor = {
          jobs = [
            {macro = "y", desc = "extensor", steps = []}
            {macro = "a", desc = "extensor", steps = []}
          ]
        }

        out = merger.merge(extensor, extended)
      )

      # (2) assessment
      expected(out.jobs).equalTo([
        {macro = "x", desc = "extended", steps = []}
        {macro = "z", desc = "extended", steps = []}
        {macro = "y", desc = "extensor", steps = []}
        {macro = "a", desc = "extensor", steps = []}
      ])
    end)

    test("when jobs are unavailable, empty list must be used", proc()
      # (1) act
      const (
        extensor = {}
        extended1 = {}
        extended2 = {
          jobs = [
            {macro = "x", desc = "extended2", steps = []}
            {macro = "y", desc = "extended2", steps = []}
            {co = "z", desc = "extended2", steps = []}
          ]
        }

        out = merger.merge(extensor, extended1, extended2)
      )

      # (2) assessment
      expected(out.jobs).equalTo([
        {macro = "x", desc = "extended2", steps = []}
        {macro = "y", desc = "extended2", steps = []}
        {co = "z", desc = "extended2", steps = []}
      ])
    end)
  end)
end)