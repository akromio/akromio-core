use (
  alias://expected
  {Ops} = alias://core
  {JobParser} = ~
)

suite(__filename, proc()
  const (
    parser = JobParser()
    ops = Ops()
  )

  suite("pareJob()", proc()
    test("when macro, a macro instance must be returned", proc()
      # (1) act
      const (
        decl = {macro = "test", local = ["v1", "v2"], steps = []}
        out = parser.parseJob(decl, ops=)
      )

      # (2) assessment
      expected(out).toBe("CatalogMacro").toHave(
        name = "test"
        local = [{var = "v1"}, {var = "v2"}]
      )
    end)

    test("when loop, a loop instance must be returned", proc()
      # (1) act
      const (
        decl = {loop = "test", steps = [], forEach = []}
        out = parser.parseJob(decl, ops=)
      )

      # (2) assessment
      expected(out).toBe("CatalogLoop").toHave(name = "test")
    end)

    test("when co, a co instance must be returned", proc()
      # (1) act
      const (
        decl = {co = "test", steps = []}
        out = parser.parseJob(decl, ops=)
      )
      
      # (2) assessment
      expected(out).toBe("CatalogCo").toHave(name = "test")
    end)

    test("when script, a script instance must be returned", proc()
      # (1) act
      const (
        decl = {script = "test", code = ""}
        out = parser.parseJob(decl, ops=)
      )

      # (2) assessment
      expected(out).toBe("Script").toHave(name = "test")
    end)

    test("when group, a job list with the group tag must be returned", proc()
      # (1) act
      const (
        decl = {
          group = "testing"
          jobs = [
            {macro = "test1", tags = ["test"], steps = []}
            {macro = "test2", tags = ["test"], steps = []}
          ]
        }
        out = parser.parseJob(decl, ops=)
      )

      # (2) assessment
      expected(out)\
        .toHaveLen(2)\
        .it(0).toBe("CatalogMacro").toHave(name = "test1", tags = ["test", "testing"])\
        .it(1).toBe("CatalogMacro").toHave(name = "test2", tags = ["test", "testing"])
    end)

    test("when other task and parseAddOnJob() not impemented, error must be raised", proc()
      # (1) act
      const (
        decl = {macr = "test", steps = []}
        out = peval(parser.parseJob(decl, ops=))
      )

      # (2) assessment
      expected(out)\
        .it(0).equalTo(false)\
        .it(1).equalTo(Error("Invalid job declaration: { macr: 'test', steps: [] }."))
    end)
  end)

  suite("parseJobs()", proc()
    test("when jobs, these must be parsed and returned as a map", proc()
      # (1) act
      const (
        macro1 = {macro = "test1", ini = [], steps = [], fin = []}
        macro2 = {loop = "test2", ini = [], steps = [], fin = [], forEach = []}
        macro3 = {macro = "test3", steps = []}
        group = {group = "testing", jobs = [macro1, macro2]}
        decl = [group, macro3]
        out = parser.parseJobs(decl, ops=)
      )

      # (2) assessment
      expected(out)\
        .toHaveLen(3)\
        .member("test1").toBe("CatalogMacro").toHave(name = "test1", tags = ["testing"])\
        .member("test2").toBe("CatalogLoop").toHave(name = "test2", tags = ["testing"])\
        .member("test3").toBe("CatalogMacro").toHave(name = "test3")
    end)

    test("when inline ini or fin, [step] must be parsed", proc()
      # (1) act
      const (
        macro = {macro = "test", ini = "log ini", steps = [], fin = "log fin"}
        decl = [macro]
        out = parser.parseJobs(decl, ops=)
      )

      # (2) assessment
      expected(out.test.initializers).equalTo(["log ini"])
      expected(out.test.finalizers).equalTo(["log fin"])
    end)
  end)
end)
