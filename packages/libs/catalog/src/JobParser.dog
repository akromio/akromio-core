use (
  {Ops, MacroOperator, CoOperator, Script, ScriptOperator} = alias://core
  ops/impl/macro/CatalogMacro
  ops/impl/co/CatalogCo
)

/**
 * The parse options.
 */
intf ParseOpts
  /**
   * The ops registry to use with the cataloged ops such as, for example,
   * the macros.
   */
  ops: Ops

/**
 * A parser of job declarations.
 */
export struct JobParser
  /**
   * Parses the job declarations,
   * returning a list with the job instances.
   */
  pub fn parseJobs(decl: map[], opts: ParseOpts) -> jobs: map
    for each job := decl do
      if (job = self.parseJob(job, opts)); job is list then
        for each aux in job do
          jobs[aux.name] = aux
      else
        jobs[job.name] = job

  /**
   * Parses a job declaration, returning its job instance.
   *
   * @remarks
   * When a group parsed, a list of instances is returned.
   * Otherwise, the job instance is returned.
   */
  pub fn parseJob(decl: map, opts: ParseOpts) -> job
    # (1) replace text item by map
    if local ::= decl.local; local is list then
      for i = 0; i < len(local); i += 1 do
        if datum ::= local[i]; datum is text then
          local[i] = {var = datum}
    
    # (2) parse job
    if "group" in decl then job = self.parseGroup(decl, opts)
    else if "macro" in decl then job = self.parseMacro(decl, opts)
    else if "co" in decl then job = self.parseCo(decl, opts)
    else if "script" in decl then job = self.parseScript(decl, opts)
    else job = self.parseAddOnJob(decl, opts)
  
  /**
   * Parses a group declaration, returning a list with the jobs.
   */
  @hidden
  pub fn parseGroup(decl: map, opts: ParseOpts) -> jobs: list
    # (1) get tag to set in the jobs
    const tag = decl.group

    # (2) parse jobs
    for each job := decl.jobs do
      job = self.parseJob(job, opts)
      job.tags.push(tag)
      jobs.push(job)
    
  /**
   * Parses an add-on job, that is, a specific job of the
   * package in use.
   *
   * @remarks
   * For example, this is used by the tests package
   * for supporting the test jobs.
   */
  @hidden
  pub fn parseAddOnJob(decl: map, opts: ParseOpts)
    throw(Error($"Invalid job declaration: ${fmt(decl)}."))
  
  /**
   * Parses a macro declaration.
   */
  @hidden
  pub fn parseMacro(decl: map, opts: ParseOpts) = CatalogMacro(
    decl{
      *
      name = decl.macro
      operator = MacroOperator()
      ops = opts.ops
      initializers = parseIni(decl)
      finalizers = parseFin(decl)
    }
  )

  /**
   * Parses a concurrent declaration.
   */
  @hidden
  pub fn parseCo(decl: map, opts: ParseOpts) = CatalogCo(
    decl{
      *
      name = decl.co
      operator = CoOperator()
      ops = opts.ops
    }
  )

  /**
   * Parses a script declaration.
   */
  @hidden
  pub fn parseScript(decl: map, opts: ParseOpts) = Script(
    decl{
      *
      name = decl.script
      operator = ScriptOperator()
    }
  )

/**
 * Parses the ini field of a declaration.
 *
 * @dev
 * This field must be a list, but only one inline step is accepted too.
 */
fn parseIni(decl: map) = if decl.ini is text then
  [decl.ini]
else
  decl.ini ?? []
end

/**
 * Parses the fin field of a declaration.
 *
 * @dev
 * Similar to parseIni().
 */
fn parseFin(decl: map) = if decl.fin is text then
  [decl.fin]
else
  decl.fin ?? []
end
