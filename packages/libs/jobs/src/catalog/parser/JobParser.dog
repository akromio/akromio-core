use (
  {Ops, MacroOperator, CoOperator, Script, ScriptOperator} = alias://core
  {CatalogMacro, CatalogCo, CatalogItemParser, CatalogItemParseOpts} = alias://catalog
)

/**
 * Parse options.
 */
intf ParseOpts: CatalogItemParseOpts
  /**
   * Ops registry to use with the cataloged ops such as,
   * for example, the macros.
   */
  ops: Ops

/**
 * A parser of job declarations.
 */
export struct JobParser: CatalogItemParser
  @override
  pub const itemName = "job"

  @override
  pub fn parseItem(decl: map, opts: ParseOpts) = self.parseJob(decl, opts)

  /**
   * Parses a job declaration, returning its job instance.
   *
   * @remarks
   * When a group parsed, a list of instances is returned.
   * Otherwise, the job instance is returned.
   */
  pub fn parseJob(decl: map, opts: ParseOpts) -> job
    # (1) replace text item by map
    if local ::= decl.dataset; local is list then
      for i = 0; i < len(local); i += 1 do
        if datum ::= local[i]; datum is text then
          local[i] = {var = datum}
    
    # (2) parse job
    if "macro" in decl then job = self.parseMacro(decl, opts)
    else if "co" in decl then job = self.parseCo(decl, opts)
    else if "script" in decl then job = self.parseScript(decl, opts)
    else job = self.parseAddOnJob(decl, opts)
  
  /**
   * Parses an add-on job, that is, a specific job of the
   * package in use.
   *
   * @remarks
   * For example, this is used by the tests package
   * for supporting the test jobs.
   */
  @hidden
  pub fn parseAddOnJob(decl: map, opts: ParseOpts)
    throw(Error($"Invalid job declaration: ${fmt(decl)}."))
  
  /**
   * Parses a macro declaration.
   */
  @hidden
  pub fn parseMacro(decl: map, opts: ParseOpts) = CatalogMacro(
    decl{
      *
      name = decl.macro
      operator = MacroOperator()
      ops = opts.ops
      initializers = parseIni(decl)
      finalizers = parseFin(decl)
    }
  )

  /**
   * Parses a concurrent declaration.
   */
  @hidden
  pub fn parseCo(decl: map, opts: ParseOpts) = CatalogCo(
    decl{
      *
      name = decl.co
      operator = CoOperator()
      ops = opts.ops
    }
  )

  /**
   * Parses a script declaration.
   */
  @hidden
  pub fn parseScript(decl: map, opts: ParseOpts) = Script(
    decl{
      *
      name = decl.script
      operator = ScriptOperator()
    }
  )

/**
 * Parses the ini field of a declaration.
 *
 * @dev
 * This field must be a list, but only one inline step is accepted too.
 */
fn parseIni(decl: map) = if decl.ini is text then
  [decl.ini]
else
  decl.ini ?? []
end

/**
 * Parses the fin field of a declaration.
 *
 * @dev
 * Similar to parseIni().
 */
fn parseFin(decl: map) = if decl.fin is text then
  [decl.fin]
else
  decl.fin ?? []
end
