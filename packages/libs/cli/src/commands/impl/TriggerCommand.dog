use (
  {Duplex} = dep://stream
  {SimpleRunner, Ops, PluginLoader, PluginParser} = alias://core
  {Trigger} = alias://trigger
  {TriggeredJobCatalogParser} = alias://jobs
  alias://intervalTriggerImpl
  dep://redis
  alias://redisStreamsTriggerImpl

  ../JobRunCommandBase
)

/**
 * The options defined in the super types.
 */
const {baseOptions} = JobRunCommandBase

/**
 * The trigger command.
 */
@abstract
export struct TriggerCommand: JobRunCommandBase
  @override
  pub const name := ["run [triggerName]", "r"]

  @override
  pub const desc := "Use a trigger to run a job of a catalog."

  @override
  pub const positionals := {
    triggerName =
      type = "string"
      desc = "Trigger name to use. If unset, defaultTriggerName used."
  }

  @override
  pub const options := {
    {registries} = baseOptions
    {catalogName} = baseOptions
    {registryAndCatalogName} = baseOptions
    {arg} = baseOptions
    {onError} = baseOptions
    {reporter} = baseOptions
    {summaryReporter} = baseOptions
  }

  /**
   * Creates and returns the catalog parser to use.
   */
  @hidden
  pub fn createCatalogParser(opts: map) = TriggeredJobCatalogParser(opts)

  @override @hidden
  pub async proc handle(
    argv=> {triggerName, catalogName, registryAndCatalogName, onError, args, reporters, summaryReporters}
  )
    # (1) create the registry instances to use
    const registries = await(self.createRegistries(argv).connect())

    do
      # (2) create the ops to use
      const ops = Ops()

      # (3) determine the catalogName
      if registryAndCatalogName then
        catalogName = registryAndCatalogName.split("://")[1]

      # (4) get the catalog decl
      const decl = await(self.readCatalogDecl(
        (catalogName = self.buildCatalogPath(catalogName))
        registries
      ))

      if not decl then
        print($"Job catalog '${catalogName}' not found in '${registries.registryNames}'.")
        ps.exit(1)

      # (5) create global dataset
      const globalDataset = await(self.createGlobalDataset(decl, args))

      # (6) create catalog instance
      const (
        pluginParser = PluginParser()
        catalog = await(self.createCatalog(decl, pluginParser, globalDataset, ops))
      )

      # (7) create engine
      const (
        log = native("new Duplex({emitClose: true, read() {}, write() {}})")
        engine = await(self.createEngine(
          {
            dataset = catalog.dataset
            onError = catalog.onError or onError
            runner = SimpleRunner(log=)
            pluginParser
            ops
          }

          registries.getRegistry(decl.registryName)
        ))
      )
      
      reporters = self.createReporters(reporters, log).connect()
      ops.appendOps(...values(catalog.jobs))

      # (8) create and run trigger
      var (
        trigger ::= createTrigger(triggerName, catalog, engine, args)
        code = 0
      )
      
      trigger.start(async proc(result?)
        do
          if result then code = 1
        finally
          await(catalog.finalize())
          ps.exit(code)
      end)
    finally
      pawait(registries.disconnect())
      peval(reporters.disconnect())

/**
 * Creates a trigger with the given data.
 */
@noParamCheck
fn createTrigger(name, cat, engine, jobArgs?) -> trigger
  # (1) pre: set name if unset
  if not (name ?= cat.defaultTriggerName) then
    throw(TypeError($"trigger name expected."))

  # (2) get the trigger implementation
  var (
    decl = cat.triggers[name] ?? throw(TypeError($"Trigger not found: ${name}."))
    TriggerImpl
  )

  with i ::= decl.impl ?? name do
    if "interval" then
      TriggerImpl = intervalTriggerImpl.impl

    if "redisstreams" then
      const opts = {
        name = decl.group.consumer
        socket =
          host = decl.host ?? "localhost"
          port = decl.port ?? 6379
        if decl.username then username = decl.username
        if decl.password then password = decl.password
      }

      TriggerImpl = redisStreamsTriggerImpl.impl
      decl = decl{*, redis = redis.createClient(opts)}
    
    else throw(TypeError($"Invalid trigger implementation: ${i}."))

  # (3) create trigger
  trigger = Trigger(
    name=,
    engine
    triggerImpl = TriggerImpl(decl)
  )
