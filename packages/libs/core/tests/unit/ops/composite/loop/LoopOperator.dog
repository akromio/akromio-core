use (
  alias://expected
  {simulator} = alias://doubles
  {GlobalDataset} = alias://dataset
  {monitor} = alias://doubles
  {DynamicLoop, LoopOperator, StaticAction, ActionOperator} = ~
)

suite(__filename, proc()
  const (
    globalDataset = GlobalDataset(name = "global")
    log = simulator.stream.duplex()
  )

  suite("performWorks()", proc()
    struct TestLoop: DynamicLoop
      @override
      pub fn getCollection() = {
        title = "get collection"
        op = StaticAction(name = "coll", fun = fn() = [1, 2] end, operator = ActionOperator())
        onError = "carryOn"
      }

      @override
      pub fn getSteps() = [
        {
          title = "1st step"
          op = StaticAction(name = "1st", fun = fn(ctx=> {params}) = $"action #${params}" end, operator = ActionOperator())
          args = "$(i)"
          onError = "carryOn"
        }

        {
          title = "2nd step"
          op = StaticAction(name = "2nd", fun = fn(ctx=> {params}) = params end, operator = ActionOperator())
          args = "action $(i)"
          resultVarName = "2nd"
          onError = "carryOn"
        }

        {
          title = "3rd step"
          op = StaticAction(name = "3rd", fun = fn(ctx=> {params}) = params end, operator = ActionOperator())
          args = "action $(i)"
          resultVarName = "3rd"
          onError = "carryOn"
          quiet = true
        }
      ]

    test("when called and everything is alright, a result for every step must be returned as value", async proc()
      # (1) act
      const (
        loop = TestLoop(name = "loop", operator = LoopOperator())
        out = await(loop.run(dataset = globalDataset, log))
      )

      # (2) assessment
      expected(out)\
        .toBe("Result")\
        .toHave(title = "loop", kind = "ok", onError = "carryOn")
      
      expected(out.value)\
        .toBeList().toHaveLen(5)\
        .it(0).toBe("Result").toHave(title = "coll", kind = "ok", value = [1, 2])\
        .it(1).toBe("Result").toHave(title = "1st", kind = "ok", value = "action #1")\
        .it(2).toBe("Result").toHave(title = "2nd", kind = "ok", value = "action 1")\
        .it(3).toBe("Result").toHave(title = "1st", kind = "ok", value = "action #2")\
        .it(4).toBe("Result").toHave(title = "2nd", kind = "ok", value = "action 2")
    end)

    test("when onError is finish and error, break must be perform and value contains the results", async proc()
      struct TestLoop: DynamicLoop
        @override
        pub fn getCollection() = {
          title = "get collection"
          op = StaticAction(name = "coll", fun = fn() = [1, 2] end, operator = ActionOperator())
          onError = "carryOn"
          resultVarName = "j"
        }

        @override
        pub fn getSteps() = [
          {
            title = "1st step"
            op = StaticAction(name = "1st", fun = fn() throw(Error("error!")) end, operator = ActionOperator())
            args = 123
            onError = "finish"
          }

          {
            title = "2nd step"
            op = StaticAction(name = "2nd", fun = fn() = "action #2" end, operator = ActionOperator())
            args = 321
            resultVarName = "2nd"
            onError = "carryOn"
          }
        ]
      
      # (1) act
      const (
        loop = TestLoop(name = "loop", operator = LoopOperator())
        out = await(loop.run(dataset = globalDataset, log))
      )

      # (2) assessment
      expected(out)\
        .toBe("Result")\
        .toHave(title = "loop", kind = "failed", onError = "carryOn")

      expected(out.value)\
        .toBeList().toHaveLen(2)\
        .it(0).toBe("Result").toHave(title = "coll", kind = "ok", value = [1, 2])\
        .it(1).toBe("Result").toHave(title = "1st", kind = "failed", value = Error("error!"))
    end)
  end)
end)