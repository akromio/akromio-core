use (
  Plugin
  ../ops/simple/action/{StaticAction, ActionOperator}
)

/**
 * Action operator to use with the plugin operations.
 */
const actionOperator = ActionOperator()

/**
 * A parser for parsing plugin declarations.
 */
export struct PluginParser
  /**
   * Parses a plugin declaration, returning its corresponding plugin instance.
   */
  pub async fn parsePlugin(decl: map, iniArgs?: any) -> plugin: Plugin
    # (1) create plugin
    const (
      name = decl.plugin
      initializer = decl.ini
      finalizer = decl.fin
    )

    plugin = Plugin(decl{*, -ops, name, finalizer})

    # (2) add its operations
    for each name, opDecl in decl.ops do
      if initializer then
        const fun = async fn(...args)
          if not plugin.initialized then
            plugin.state = await(initializer(iniArgs))
            plugin.initialized = true
          
          return opDecl.fun(args[0]{*, state = plugin.state}, ...args[1, -1])
        end

        plugin.state = {}
        plugin.appendOp(StaticAction(opDecl{*, fun, name, operator = actionOperator}))
      else
        plugin.appendOp(StaticAction(opDecl{*, name, operator = actionOperator}))
  
  /**
   * Parses a preset declaration, returning its corresponding plugin
   * instances.
   */
  pub async fn parsePreset(preset: map) -> plugins: list
    for each def in preset.plugins do
      plugins.push(await(self.parsePlugin(def.impl, def.iniArgs)))
