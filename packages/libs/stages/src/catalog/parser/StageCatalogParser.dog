use (
  {Dataset} = alias://dataset
  {CatalogParser, CatalogParseOpts} = alias://catalog

  ../StageCatalog
  ../../stages/{ConstStageParser, SleepStageParser}
)

/**
 * The const stage parser to use.
 */
const constStageParser = ConstStageParser()

/**
 * The sleep stage parser to use.
 */
const sleepStageParser = SleepStageParser()

/**
 * Stage catalog parse options.
 */
type StageCatalogParseOpts = CatalogParseOpts

/**
 * A parser to parse stage catalog declarations.
 */
export struct StageCatalogParser: CatalogParser
  @override @hidden
  pub fn createCatalog(decl: map) = StageCatalog(decl)

  @override @hidden
  pub fn parseSpecialization(decl: map, opts: StageCatalogParseOpts) = decl{
    *
    stages = self.parseStages(decl.stages, decl.dataset)
  }
  
  /**
   * Parses the stage [decl]arations.
   */
  @hidden
  pub fn parseStages(decl: map[], dataset: Dataset) -> stages: map
    for each stage := decl do
      if "const" in stage then stage = constStageParser.parse(stage, dataset)
      else if "sleep" in stage then stage = sleepStageParser.parse(stage, dataset)
      else throw(TypeError($"Unknown stage: ${fmt(stage)}."))
      
      stages[stage.name] = stage
