use (
  {Dataset} = alias://dataset
  {CatalogParser, CatalogParseOpts} = alias://catalog

  StageCatalog
  ../stages/{ConstStageParser, SleepStageParser}
)

/**
 * The const stage parser to use.
 */
const constStageParser = ConstStageParser()

/**
 * The sleep stage parser to use.
 */
const sleepStageParser = SleepStageParser()

/**
 * Stage catalog parse options.
 */
type StageCatalogParseOpts = CatalogParseOpts

/**
 * A parser to parse stage catalog declarations.
 */
export struct StageCatalogParser: CatalogParser
  @override @hidden
  pub fn createCatalog(decl: map) = StageCatalog(decl)

  @override @hidden
  pub fn parseSpecific(decl: map, opts: StageCatalogParseOpts) = decl{
    *
    stages = self.parseStages(decl.stages, decl.dataset)
  }
  
  /**
   * Parses the stage [decl]arations.
   */
  @hidden
  pub fn parseStages(decl: map[], dataset: Dataset) -> stages: map
    for each stage := decl do
      with i ::= stage.impl do
        if "const" then stage = constStageParser.parse(stage, dataset)
        if "sleep" then stage = sleepStageParser.parse(stage, dataset)
        else throw(TypeError($"Unknown stage impl: ${i}."))
      
      stages[stage.stage] = stage
